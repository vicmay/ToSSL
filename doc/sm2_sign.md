# ::tossl::sm2::sign

Create an SM2 digital signature using a private key and message.

## Overview

`::tossl::sm2::sign` creates a digital signature for a given message using an SM2 private key. SM2 is a Chinese national standard for elliptic curve cryptography that provides both digital signature and encryption capabilities. The signature can later be verified using the corresponding public key.

## Syntax

```
tossl::sm2::sign <private_key_pem> <data>
```

- `<private_key_pem>`: The SM2 private key in PEM format.
- `<data>`: The message string to sign.

## Example

```tcl
# Generate SM2 key pair
set key_pair [tossl::sm2::generate]
set private_key $key_pair
set public_key [tossl::key::getpub -key $private_key]

# Sign data
set data "Hello, SM2!"
set signature [tossl::sm2::sign $private_key $data]

# Verify signature
set valid [tossl::sm2::verify $public_key $data $signature]
if {$valid} {
    puts "Signature is valid!"
} else {
    puts "Signature is invalid!"
}
```

## Return Value

- Returns a binary signature as a byte array object.
- Returns an error if the private key or data is invalid.

## Error Handling

- Returns an error if the private key is not a valid SM2 or EC key with SM2 curve.
- Returns an error if the private key format is invalid.
- Returns an error if the wrong number of arguments is provided.
- Returns an error if memory allocation fails during signing.

## Security Considerations

- **Key Security**: Keep private keys secure and never expose them in logs or outputs.
- **Signature Uniqueness**: SM2 signatures may include random components, so the same data signed multiple times may produce different signatures.
- **Cryptographic Strength**: SM2 uses elliptic curve cryptography with the SM2 curve, providing strong security.
- **Data Integrity**: The signature ensures that the data has not been tampered with since signing.

## Best Practices

- Always use keys generated by secure cryptographic processes.
- Handle private keys securely and never transmit them over insecure channels.
- Verify signatures before trusting signed data.
- Use appropriate key sizes and secure random number generation.
- Do not expose private key material in logs or outputs.

## Advanced Usage

### Batch Signature Creation

```tcl
# Sign multiple messages efficiently
proc sign_multiple_messages {private_key messages} {
    set signatures {}
    foreach message $messages {
        set sig [tossl::sm2::sign $private_key $message]
        lappend signatures $sig
    }
    return $signatures
}

# Usage
set messages {
    "Message 1"
    "Message 2"
    "Message 3"
}
set signatures [sign_multiple_messages $private_key $messages]
```

### Signature Creation with Error Handling

```tcl
# Robust signature creation with detailed error handling
proc sign_data_robust {private_key data} {
    if {[catch {
        set signature [tossl::sm2::sign $private_key $data]
        return [dict create success 1 signature $signature error ""]
    } err]} {
        return [dict create success 0 signature "" error $err]
    }
}

# Usage
set result [sign_data_robust $private_key "Important data"]
if {[dict get $result success]} {
    puts "Signature created successfully"
    set signature [dict get $result signature]
} else {
    puts "Signing failed: [dict get $result error]"
}
```

### SM2 Signature Compliance Testing

```tcl
# Test SM2 signature compliance
proc test_sm2_compliance {private_key} {
    puts "=== SM2 Compliance Testing ==="
    
    # Test with various data types
    set test_cases {
        "Simple text message"
        ""
        "Binary data: [format %c 0x00][format %c 0xFF]"
        [string repeat "Long message " 100]
    }
    
    foreach test_data $test_cases {
        if {[catch {
            set signature [tossl::sm2::sign $private_key $test_data]
            puts "✓ Test case passed: [string length $test_data] bytes -> [string length $signature] bytes"
        } err]} {
            puts "✗ Test case failed: $err"
        }
    }
    
    puts "✓ SM2 compliance testing completed"
}
```

## Performance Considerations

- **Efficient Implementation**: Uses OpenSSL's optimized SM2 implementation.
- **Memory Management**: Efficient memory allocation and cleanup.
- **Batch Processing**: Can handle multiple signing operations efficiently.

### Performance Monitoring

```tcl
# Monitor signing performance
proc benchmark_sm2_signing {private_key data iterations} {
    set start_time [clock milliseconds]
    
    for {set i 0} {$i < $iterations} {incr i} {
        set signature [tossl::sm2::sign $private_key $data]
        if {[string length $signature] == 0} {
            error "Empty signature generated on iteration $i"
        }
    }
    
    set end_time [clock milliseconds]
    set total_time [expr {$end_time - $start_time}]
    set avg_time [expr {double($total_time) / $iterations}]
    
    return [dict create \
        total_time $total_time \
        average_time $avg_time \
        operations_per_second [expr {double($iterations) * 1000 / $total_time}]]
}

# Usage
set benchmark [benchmark_sm2_signing $private_key "test data" 100]
puts "Average signing time: [dict get $benchmark average_time]ms"
puts "Operations per second: [format %.2f [dict get $benchmark operations_per_second]]"
```

## Integration Examples

### SM2 Signature in Web Applications

```tcl
# Create SM2 signatures in web application context
proc sign_web_request {private_key request_data} {
    # Create signature for API request
    set signature [tossl::sm2::sign $private_key $request_data]
    
    # Convert to hex for transmission
    set signature_hex ""
    for {set i 0} {$i < [string length $signature]} {incr i} {
        append signature_hex [format %02x [scan [string index $signature $i] %c]]
    }
    
    return $signature_hex
}

# Usage in web application
set request_body "{\"user\":\"alice\",\"action\":\"transfer\"}"
set signature_hex [sign_web_request $private_key $request_body]
puts "API request signature: $signature_hex"
```

### SM2 Signature in File Integrity

```tcl
# Sign file content using SM2
proc sign_file_sm2 {private_key filename} {
    # Read file content
    set file_handle [open $filename r]
    set content [read $file_handle]
    close $file_handle
    
    # Sign content
    set signature [tossl::sm2::sign $private_key $content]
    
    # Write signature to file
    set signature_filename "${filename}.sm2.sig"
    set file_handle [open $signature_filename wb]
    puts -nonewline $file_handle $signature
    close $file_handle
    
    return $signature_filename
}

# Usage
set signature_file [sign_file_sm2 $private_key "important_document.pdf"]
puts "File signed: $signature_file"
```

### Digital Certificate Creation

```tcl
# Create a simple digital certificate with SM2 signature
proc create_sm2_certificate {private_key subject_name public_key} {
    # Create certificate data
    set cert_data "Subject: $subject_name\nPublic Key: $public_key\nIssued: [clock format [clock seconds]]"
    
    # Sign the certificate
    set signature [tossl::sm2::sign $private_key $cert_data]
    
    # Create certificate structure
    return [dict create \
        data $cert_data \
        signature $signature \
        algorithm "SM2" \
        issuer "Self-Signed"]
}

# Usage
set cert [create_sm2_certificate $private_key "Alice Smith" $public_key]
puts "Certificate created: [dict get $cert data]"
```

## Troubleshooting

### Common Issues

1. **"Not an SM2 or EC key" error**
   - Ensure the private key is a valid SM2 key or EC key with SM2 curve
   - Check that the key is in PEM format

2. **"Failed to parse private key" error**
   - Verify the PEM format is correct
   - Ensure the key is a private key, not a public key

3. **"Failed to initialize signing" error**
   - Check that OpenSSL supports SM2
   - Verify the key type is compatible

### Debug Information

```tcl
# Debug signature creation
proc debug_sign_data {private_key data} {
    puts "Debug: Private key length: [string length $private_key]"
    puts "Debug: Data length: [string length $data]"
    puts "Debug: Data preview: [string range $data 0 50]..."
    
    if {[catch {
        set signature [tossl::sm2::sign $private_key $data]
        puts "Debug: Signature created successfully"
        puts "Debug: Signature length: [string length $signature]"
        return $signature
    } err]} {
        puts "Debug: Signing error: $err"
        return ""
    }
}
```

## Signature Format

SM2 signatures are returned as binary data (byte arrays) with the following characteristics:

- **Length**: Typically 64-128 bytes
- **Format**: Raw binary signature data
- **Encoding**: No additional encoding (raw bytes)
- **Compatibility**: Compatible with OpenSSL's SM2 implementation

### Signature Conversion

```tcl
# Convert signature to hex string
proc signature_to_hex {signature} {
    set hex ""
    for {set i 0} {$i < [string length $signature]} {incr i} {
        append hex [format %02x [scan [string index $signature $i] %c]]
    }
    return $hex
}

# Convert hex string back to signature
proc hex_to_signature {hex_string} {
    set signature ""
    for {set i 0} {$i < [string length $hex_string]} {incr i 2} {
        append signature [format %c [scan [string range $hex_string $i [expr {$i+1}]] %x]]
    }
    return $signature
}

# Usage
set signature [tossl::sm2::sign $private_key "test data"]
set hex_sig [signature_to_hex $signature]
puts "Hex signature: $hex_sig"

set restored_sig [hex_to_signature $hex_sig]
set verify_result [tossl::sm2::verify $public_key "test data" $restored_sig]
puts "Verification result: $verify_result"
```

## See Also

- `::tossl::sm2::verify` - Verify SM2 digital signatures
- `::tossl::sm2::generate` - Generate SM2 key pairs
- `::tossl::sm2::encrypt` - Encrypt data using SM2
- `::tossl::sm2::decrypt` - Decrypt data using SM2
- `::tossl::key::getpub` - Extract public key from private key
- `::tossl::ec::sign` - Create EC digital signatures
- `::tossl::rsa::sign` - Create RSA digital signatures

## Standards Compliance

- **GB/T 32918.1-2016**: Chinese national standard for SM2 elliptic curve cryptography
- **RFC 5639**: Elliptic Curve Cryptography (ECC) Brainpool Standard Curves and Curve Generation
- **OpenSSL Compatibility**: Uses OpenSSL's SM2 implementation for maximum compatibility 