# ::tossl::sm2::decrypt

Decrypt SM2 encrypted data using a private key.

## Overview

`::tossl::sm2::decrypt` decrypts data that was previously encrypted using SM2 public key encryption. SM2 is a Chinese national standard for elliptic curve cryptography that provides both digital signature and encryption capabilities. This command uses the private key corresponding to the public key used for encryption.

## Syntax

```
tossl::sm2::decrypt <private_key_pem> <encrypted_data>
```

- `<private_key_pem>`: The SM2 private key in PEM format.
- `<encrypted_data>`: The encrypted data as a binary string (output of `tossl::sm2::encrypt`).

## Example

```tcl
# Generate SM2 key pair
set key_pair [tossl::sm2::generate]
set private_key $key_pair
set public_key [tossl::key::getpub -key $private_key]

# Encrypt data
set data "Hello, SM2!"
set encrypted [tossl::sm2::encrypt $public_key $data]

# Decrypt data
set decrypted [tossl::sm2::decrypt $private_key $encrypted]
if {$decrypted eq $data} {
    puts "Decryption successful: $decrypted"
} else {
    puts "Decryption failed"
}
```

## Return Value

- Returns the decrypted data as a string.
- Returns an error if the private key or encrypted data is invalid.

## Error Handling

- Returns an error if the private key is not a valid SM2 or EC key with SM2 curve.
- Returns an error if the private key format is invalid.
- Returns an error if the encrypted data format is invalid or corrupted.
- Returns an error if the wrong number of arguments is provided.
- Returns an error if memory allocation fails during decryption.

## Security Considerations

- **Key Security**: Keep private keys secure and never expose them in logs or outputs.
- **Data Integrity**: SM2 encryption provides confidentiality but not integrity by default.
- **Cryptographic Strength**: SM2 uses elliptic curve cryptography with the SM2 curve, providing strong security.
- **Key Management**: Ensure the private key corresponds to the public key used for encryption.

## Best Practices

- Always use keys generated by secure cryptographic processes.
- Handle private keys securely and never transmit them over insecure channels.
- Verify the source of encrypted data before decryption.
- Use appropriate key sizes and secure random number generation.
- Do not expose private key material in logs or outputs.

## Advanced Usage

### Batch Decryption

```tcl
# Decrypt multiple encrypted messages efficiently
proc decrypt_multiple_messages {private_key encrypted_messages} {
    set decrypted_messages {}
    foreach encrypted $encrypted_messages {
        set decrypted [tossl::sm2::decrypt $private_key $encrypted]
        lappend decrypted_messages $decrypted
    }
    return $decrypted_messages
}

# Usage
set encrypted_list {
    $encrypted1
    $encrypted2
    $encrypted3
}
set decrypted_list [decrypt_multiple_messages $private_key $encrypted_list]
```

### Decryption with Error Handling

```tcl
# Robust decryption with detailed error handling
proc decrypt_data_robust {private_key encrypted_data} {
    if {[catch {
        set decrypted [tossl::sm2::decrypt $private_key $encrypted_data]
        return [dict create success 1 decrypted $decrypted error ""]
    } err]} {
        return [dict create success 0 decrypted "" error $err]
    }
}

# Usage
set result [decrypt_data_robust $private_key $encrypted_data]
if {[dict get $result success]} {
    puts "Decryption successful: [dict get $result decrypted]"
} else {
    puts "Decryption failed: [dict get $result error]"
}
```

### SM2 Decryption Compliance Testing

```tcl
# Test SM2 decryption compliance
proc test_sm2_compliance {private_key public_key} {
    puts "=== SM2 Compliance Testing ==="
    
    # Test with various data types
    set test_cases {
        "Simple text message"
        ""
        "Binary data: [format %c 0x00][format %c 0xFF]"
        [string repeat "Long message " 100]
    }
    
    foreach test_data $test_cases {
        if {[catch {
            set encrypted [tossl::sm2::encrypt $public_key $test_data]
            set decrypted [tossl::sm2::decrypt $private_key $encrypted]
            if {$decrypted eq $test_data} {
                puts "✓ Test case passed: [string length $test_data] bytes"
            } else {
                puts "✗ Test case failed: data mismatch"
            }
        } err]} {
            puts "✗ Test case failed: $err"
        }
    }
    
    puts "✓ SM2 compliance testing completed"
}
```

## Performance Considerations

- **Efficient Implementation**: Uses OpenSSL's optimized SM2 implementation.
- **Memory Management**: Efficient memory allocation and cleanup.
- **Batch Processing**: Can handle multiple decryption operations efficiently.

### Performance Monitoring

```tcl
# Monitor decryption performance
proc benchmark_sm2_decryption {private_key public_key data iterations} {
    # First encrypt the data
    set encrypted [tossl::sm2::encrypt $public_key $data]
    
    set start_time [clock milliseconds]
    
    for {set i 0} {$i < $iterations} {incr i} {
        set decrypted [tossl::sm2::decrypt $private_key $encrypted]
        if {$decrypted ne $data} {
            error "Decryption failed on iteration $i"
        }
    }
    
    set end_time [clock milliseconds]
    set total_time [expr {$end_time - $start_time}]
    set avg_time [expr {double($total_time) / $iterations}]
    
    return [dict create \
        total_time $total_time \
        average_time $avg_time \
        operations_per_second [expr {double($iterations) * 1000 / $total_time}]]
}

# Usage
set benchmark [benchmark_sm2_decryption $private_key $public_key "test data" 10]
puts "Average decryption time: [dict get $benchmark average_time]ms"
puts "Operations per second: [format %.2f [dict get $benchmark operations_per_second]]"
```

## Integration Examples

### SM2 Decryption in Web Applications

```tcl
# Decrypt SM2 encrypted data in web application context
proc decrypt_web_data {private_key encrypted_hex} {
    # Convert hex encrypted data to binary
    set encrypted ""
    for {set i 0} {$i < [string length $encrypted_hex]} {incr i 2} {
        append encrypted [format %c [scan [string range $encrypted_hex $i [expr {$i+1}]] %x]]
    }
    
    # Decrypt data
    return [tossl::sm2::decrypt $private_key $encrypted]
}

# Usage in web application
set encrypted_hex "a1b2c3d4e5f6..."
set decrypted_data [decrypt_web_data $private_key $encrypted_hex]
puts "Decrypted data: $decrypted_data"
```

### SM2 Decryption in File Processing

```tcl
# Decrypt file content using SM2
proc decrypt_file_sm2 {private_key encrypted_filename} {
    # Read encrypted file content
    set file_handle [open $encrypted_filename r]
    set encrypted_content [read $file_handle]
    close $file_handle
    
    # Decrypt content
    set decrypted_content [tossl::sm2::decrypt $private_key $encrypted_content]
    
    # Write decrypted content
    set decrypted_filename [string range $encrypted_filename 0 end-4]  ;# Remove .sm2
    set file_handle [open $decrypted_filename w]
    puts -nonewline $file_handle $decrypted_content
    close $file_handle
    
    return $decrypted_filename
}

# Usage
set decrypted_file [decrypt_file_sm2 $private_key "document.pdf.sm2"]
puts "File decrypted: $decrypted_file"
```

### Secure Message Exchange

```tcl
# Complete secure message exchange using SM2
proc secure_message_exchange {sender_private_key recipient_public_key message} {
    # Encrypt message for recipient
    set encrypted_message [tossl::sm2::encrypt $recipient_public_key $message]
    
    # Sign the encrypted message for authentication
    set signature [tossl::sm2::sign $sender_private_key $encrypted_message]
    
    return [dict create \
        encrypted $encrypted_message \
        signature $signature]
}

proc receive_secure_message {recipient_private_key sender_public_key encrypted_message signature} {
    # Verify signature
    set signature_valid [tossl::sm2::verify $sender_public_key $encrypted_message $signature]
    if {!$signature_valid} {
        error "Message signature verification failed"
    }
    
    # Decrypt message
    set decrypted_message [tossl::sm2::decrypt $recipient_private_key $encrypted_message]
    
    return $decrypted_message
}

# Usage
set alice_keys [tossl::sm2::generate]
set bob_keys [tossl::sm2::generate]
set alice_private [dict get $alice_keys private]
set alice_public [tossl::key::getpub -key $alice_private]
set bob_private [dict get $bob_keys private]
set bob_public [tossl::key::getpub -key $bob_private]

# Alice sends message to Bob
set message "Hello, Bob! This is a secure message."
set secure_package [secure_message_exchange $alice_private $bob_public $message]

# Bob receives and decrypts message
set received_message [receive_secure_message $bob_private $alice_public \
    [dict get $secure_package encrypted] [dict get $secure_package signature]]

puts "Received message: $received_message"
```

## Troubleshooting

### Common Issues

1. **"Not an SM2 or EC key" error**
   - Ensure the private key is a valid SM2 key or EC key with SM2 curve
   - Check that the key is in PEM format

2. **"Failed to parse private key" error**
   - Verify the PEM format is correct
   - Ensure the key is a private key, not a public key

3. **"Failed to decrypt data" error**
   - Check that the encrypted data was created with the corresponding public key
   - Verify the encrypted data format is correct
   - Ensure the encrypted data hasn't been corrupted

4. **"Failed to initialize decryption" error**
   - Check that OpenSSL supports SM2
   - Verify the key type is compatible

### Debug Information

```tcl
# Debug decryption process
proc debug_decrypt_data {private_key encrypted_data} {
    puts "Debug: Private key length: [string length $private_key]"
    puts "Debug: Encrypted data length: [string length $encrypted_data]"
    
    if {[catch {
        set decrypted [tossl::sm2::decrypt $private_key $encrypted_data]
        puts "Debug: Decryption successful"
        puts "Debug: Decrypted data length: [string length $decrypted]"
        puts "Debug: Decrypted data preview: [string range $decrypted 0 50]..."
        return $decrypted
    } err]} {
        puts "Debug: Decryption error: $err"
        return ""
    }
}
```

## Data Format

SM2 encrypted data has the following characteristics:

- **Format**: Binary data (byte arrays)
- **Length**: Typically larger than the original data due to encryption overhead
- **Encoding**: Raw binary format, no additional encoding
- **Compatibility**: Compatible with OpenSSL's SM2 implementation

### Data Conversion

```tcl
# Convert encrypted data to hex string for storage/transmission
proc encrypted_to_hex {encrypted_data} {
    set hex ""
    for {set i 0} {$i < [string length $encrypted_data]} {incr i} {
        append hex [format %02x [scan [string index $encrypted_data $i] %c]]
    }
    return $hex
}

# Convert hex string back to encrypted data
proc hex_to_encrypted {hex_string} {
    set encrypted ""
    for {set i 0} {$i < [string length $hex_string]} {incr i 2} {
        append encrypted [format %c [scan [string range $hex_string $i [expr {$i+1}]] %x]]
    }
    return $encrypted
}

# Usage
set encrypted [tossl::sm2::encrypt $public_key "secret data"]
set hex_encrypted [encrypted_to_hex $encrypted]
puts "Hex encrypted: $hex_encrypted"

set restored_encrypted [hex_to_encrypted $hex_encrypted]
set decrypted [tossl::sm2::decrypt $private_key $restored_encrypted]
puts "Decrypted: $decrypted"
```

## See Also

- `::tossl::sm2::encrypt` - Encrypt data using SM2
- `::tossl::sm2::sign` - Create SM2 digital signatures
- `::tossl::sm2::verify` - Verify SM2 digital signatures
- `::tossl::sm2::generate` - Generate SM2 key pairs
- `::tossl::key::getpub` - Extract public key from private key
- `::tossl::ec::decrypt` - Decrypt data using EC
- `::tossl::rsa::decrypt` - Decrypt data using RSA

## Standards Compliance

- **GB/T 32918.1-2016**: Chinese national standard for SM2 elliptic curve cryptography
- **RFC 5639**: Elliptic Curve Cryptography (ECC) Brainpool Standard Curves and Curve Generation
- **OpenSSL Compatibility**: Uses OpenSSL's SM2 implementation for maximum compatibility 